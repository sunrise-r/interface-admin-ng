<!-- Define the recursive template. -->
<ng-template #nodeTemplateRef let-item>
    <ul [ngClass]="{'catalog-tree': item.hasItems()}">
        <li [hidden]="!item.visible">
            <ng-container *ngIf="item.hasItems(); then iterateItems; else printLink"></ng-container>
            <ng-template #iterateItems>
                <!-- Invoke the recursive template. -->
                <span jhiTranslate="{{item.name}}"></span>
                <ng-template
                    ngFor
                    [ngForOf]="item.items"
                    [ngForTemplate]="nodeTemplateRef">
                    <!--
                        NOTE: The "$implicit" property of the ngFor context is what will
                        be made available to the template ref's implicit let-item binding.
                    -->
                </ng-template>
            </ng-template>
            <ng-template #printLink>
                <a (click)="onClick(item)" jhiTranslate="{{item.name}}"></a>
            </ng-template>
        </li>
    </ul>
</ng-template>

<!--
    Initiate the recursive template rendering. Because our recursive template is going to
    be using the ngFor directive to render recursively, the "context" in the recursive
    instances is going to be the ngForContext. As such, we have to "mock" the initial
    context to look like the context that the ngFor directive will expose internally.

    NOTE: If we used ngContainer or ngTemplate to invoke the recursion internally, we'd
    have more control over which values were made available at each level.
-->
<ng-template [ngIf]="innerCatalogTree">
    <ng-template
        [ngTemplateOutlet]="nodeTemplateRef"
        [ngTemplateOutletContext]="{ $implicit: innerCatalogTree[0] }">
    </ng-template>
</ng-template>
